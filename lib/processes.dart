import 'package:queueing_simulator/util/stats.dart';

// Base class for all process types.
abstract class Process {
  final String name;

  Process(this.name);

  // Returns a list of all events generated by this process.
  List<Event> generateEvents();

  // Factory method to create process dynamically
  static Process createProcess(String name, Map<String, dynamic> fields) {
    switch (fields['type']) {
      case 'singleton':
        return SingletonProcess(
          name,
          fields['duration'] as int,
          fields['arrival'] as int,
        );
      case 'periodic':
        return PeriodicProcess(
          name,
          fields['duration'] as int,
          fields['interarrival-time'] as int,
          fields['first-arrival'] as int,
          fields['num-repetitions'] as int,
        );
      case 'stochastic':
        return StochasticProcess(
          name,
          (fields['mean-duration'] as num).toDouble(),
          (fields['mean-interarrival-time'] as num).toDouble(),
          fields['first-arrival'] as int,
          fields['end'] as int,
          seed: fields.containsKey('seed') ? fields['seed'] : null,
        );
      default:
        throw Exception('Unknown process type: ${fields['type']}');
    }
  }
}

// An event that occurs once at a fixed time.
class Event {
  final String processName;
  final int arrivalTime;
  final int duration;
  int waitTime = 0;  // Field to store the calculated wait time.

  Event(this.processName, this.arrivalTime, this.duration);
}

// Singleton Process
class SingletonProcess extends Process {
  final int duration;
  final int arrivalTime;

  SingletonProcess(String name, this.duration, this.arrivalTime) : super(name);

  @override
  List<Event> generateEvents() {
    return [Event(name, arrivalTime, duration)];
  }
}

// Periodic Process
class PeriodicProcess extends Process {
  final int duration;
  final int interarrivalTime;
  final int firstArrival;
  final int numRepetitions;

  PeriodicProcess(String name, this.duration, this.interarrivalTime, this.firstArrival, this.numRepetitions)
      : super(name);

  @override
  List<Event> generateEvents() {
    List<Event> events = [];
    for (int i = 0; i < numRepetitions; i++) {
      events.add(Event(name, firstArrival + i * interarrivalTime, duration));
    }
    return events;
  }
}

// Stochastic Process
class StochasticProcess extends Process {
  final ExpDistribution durationDistribution;
  final ExpDistribution interarrivalDistribution;
  final int firstArrival;
  final int end;

  StochasticProcess(String name, double meanDuration, double meanInterarrivalTime, this.firstArrival, this.end,
      {int? seed})
      : durationDistribution = seed != null 
            ? ExpDistribution(mean: meanDuration, seed: seed) 
            : ExpDistribution(mean: meanDuration),
        interarrivalDistribution = seed != null 
            ? ExpDistribution(mean: meanInterarrivalTime, seed: seed) 
            : ExpDistribution(mean: meanInterarrivalTime),
        super(name);

  @override
  List<Event> generateEvents() {
    List<Event> events = [];
    int time = firstArrival;

    // Generate events until time exceeds the 'end' value.
    while (time < end) {
      // Generate random duration and interarrival times using ExpDistribution.
      int duration = durationDistribution.next().round();

      // Allow the last event if its arrival time is within bounds, even if it slightly exceeds 'end'.
      if (time < end) {
        events.add(Event(name, time, duration));
      }

      // Update the time for the next event's arrival.
      time += interarrivalDistribution.next().round();

      // Ensure no more events are generated beyond the 'end' time limit.
      if (time >= end) {
        break;
      }
    }

    return events;
  }
}
